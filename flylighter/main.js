/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FlylighterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/uri/routes.ts
function callback(url, data) {
  let formatData = JSON.stringify(data);
  let encodedData = encodeURIComponent(formatData);
  let fullUrl = url + "&data=" + encodedData;
  window.open(fullUrl, "_blank");
}
var routes = [
  {
    path: "/tags",
    params: [],
    method: "GET",
    handler: (_app) => {
      return async (params) => {
        console.log("params", params);
        let tags = _app.metadataCache.getTags();
        callback(params["x-success"], tags);
      };
    }
  },
  {
    path: "/files",
    params: [],
    method: "GET",
    handler: (_app) => {
      return async (params) => {
        console.log("app", _app);
        let getFiles = Object.values(
          _app.vault.getMarkdownFiles()
        );
        let files = getFiles.map((file) => {
          return {
            basename: file.basename,
            extension: file.extension,
            path: file.path,
            name: file.name,
            stat: file.stat
          };
        });
        callback(params["x-success"], files);
      };
    }
  },
  {
    path: "/properties",
    params: [],
    method: "GET",
    handler: (_app) => {
      return async (params) => {
        let cachedPropertyOptions = {};
        let properties = _app.metadataCache.getAllPropertyInfos();
        let propertiesWithOptions = Object.values(properties).map((prop) => {
          if (cachedPropertyOptions["prop.name"])
            return { ...prop, options: cachedPropertyOptions["prop.name"] };
          let options = _app.metadataCache.getFrontmatterPropertyValuesForKey(
            prop.name
          );
          if (options)
            cachedPropertyOptions[prop.name] = options;
          return { ...prop, options };
        });
        callback(params["x-success"], propertiesWithOptions);
      };
    }
  },
  {
    path: "/directories",
    params: [],
    method: "GET",
    handler: (_app) => {
      return async (params) => {
        var _a, _b, _c;
        let iconicPluginSettings = (_c = (_b = (_a = _app.plugins.plugins) == null ? void 0 : _a["iconic"]) == null ? void 0 : _b.settings) == null ? void 0 : _c.fileIcons;
        let directories = Object.values(_app.vault.getAllFolders(false)).map(
          (fi) => {
            var _a2, _b2;
            return {
              name: fi.name,
              path: fi.path,
              icon: (_b2 = (_a2 = iconicPluginSettings == null ? void 0 : iconicPluginSettings[fi.path]) == null ? void 0 : _a2.icon) != null ? _b2 : "folder"
            };
          }
        );
        callback(params["x-success"], directories);
      };
    }
  },
  {
    path: "/vault/info",
    params: [],
    method: "GET",
    handler: (_app) => {
      return async (params) => {
        let hasPeriodicNotes = _app.plugins.enabledPlugins.has("periodic-notes");
        console.log("hasPeriodicNotes", hasPeriodicNotes);
        let vaultName = _app.vault.getName();
        let returnInfo = {
          name: vaultName,
          id: _app.appId
        };
        callback(params["x-success"], returnInfo);
      };
    }
  },
  {
    path: "/templates",
    params: [],
    method: "GET",
    handler: (_app) => {
      return async (params) => {
        var _a, _b, _c;
        let pre_templates = (_c = (_b = (_a = _app.plugins.plugins) == null ? void 0 : _a["templater-obsidian"]) == null ? void 0 : _b.settings) == null ? void 0 : _c.folder_templates;
        let templates = pre_templates.map((template) => {
          var _a2;
          return {
            path: template.folder,
            file: template.template,
            properties: (_a2 = _app.metadataCache.getCache(template.template)) == null ? void 0 : _a2.frontmatter
          };
        });
        console.log("templates", templates);
        callback(params["x-success"], templates);
      };
    }
  },
  {
    path: "/capture/page",
    params: ["path", "data"],
    method: "GET",
    handler: (_app) => {
      return async (params) => {
        var _a;
        try {
          let pathy = "";
          let filey = "";
          let datay = "";
          if (params.pathy) {
            pathy = decodeURIComponent(params.pathy);
          }
          if (params.file) {
            filey = decodeURIComponent(params.file);
          }
          datay = params.data;
          if (!pathy && !filey && !datay)
            return;
          let filePathFull = pathy + "/" + filey;
          let createdFile = await _app.vault.create(filePathFull, datay);
          let createdFileUrl = encodeURIComponent(
            `obsidian://open?vault=${_app.vault.getName()}&file=${createdFile.path}`
          );
          callback(params["x-success"], createdFileUrl);
          if (params.openBehavior === "openInObsidian") {
            (_a = _app.workspace.getMostRecentLeaf()) == null ? void 0 : _a.openFile(createdFile);
          }
        } catch (e) {
          callback(params["x-error"], e);
        }
      };
    }
  },
  {
    path: "/capture/append",
    params: ["path", "data"],
    method: "GET",
    handler: (_app) => {
      return async (params) => {
        var _a;
        try {
          let pathy = "";
          let filey = "";
          let datay = "";
          if (params.pathy) {
            pathy = decodeURIComponent(params.pathy);
          }
          if (params.file) {
            filey = decodeURIComponent(params.file);
          }
          datay = params.data;
          if (!pathy && !filey && !datay)
            return;
          let filePathFull = _app.vault.getFileByPath(pathy);
          let createdFile = await _app.vault.append(filePathFull, datay);
          let createdFileUrl = encodeURIComponent(
            `obsidian://open?vault=${_app.vault.getName()}&file=${filePathFull.path}`
          );
          callback(params["x-success"], createdFileUrl);
          if (params.openBehavior === "openInObsidian") {
            (_a = _app.workspace.getMostRecentLeaf()) == null ? void 0 : _a.openFile(filePathFull);
          }
        } catch (e) {
          callback(params["x-error"], e);
        }
      };
    }
  }
];

// main.ts
var FlylighterPlugin = class extends import_obsidian.Plugin {
  async onload() {
    let _app = this.app;
    routes.forEach((route) => {
      this.registerObsidianProtocolHandler(
        "flylighter" + route.path,
        route.handler(_app)
      );
    });
  }
};
