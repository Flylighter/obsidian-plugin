/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FlylighterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/uri/routes.ts
function callback(url, data) {
  let formatData = JSON.stringify(data);
  let encodedData = encodeURIComponent(formatData);
  let fullUrl = url + "&data=" + encodedData;
  window.open(fullUrl, "_blank");
}
var routes = [
  {
    path: "/tags",
    params: [],
    method: "GET",
    handler: (app) => {
      return async (params) => {
        console.log("params", params);
        let tags = app.metadataCache.getTags();
        callback(params["x-success"], tags);
      };
    }
  },
  {
    path: "/files",
    params: [],
    method: "GET",
    handler: (app) => {
      return async (params) => {
        let files = Object.values(app.metadataCache.vault.fileMap);
        for (let file of files) {
          file.parent = null;
          file.vault = null;
          file.children = null;
        }
        callback(params["x-success"], files);
      };
    }
  },
  {
    path: "/properties",
    params: [],
    method: "GET",
    handler: (app) => {
      return async (params) => {
        let properties = app.metadataCache.getAllPropertyInfos();
        let propertiesWithOptions = Object.values(properties).map((prop) => {
          let options = app.metadataCache.getFrontmatterPropertyValuesForKey(
            prop.name
          );
          return { ...prop, options };
        });
        callback(params["x-success"], propertiesWithOptions);
      };
    }
  },
  {
    path: "/directories",
    params: [],
    method: "GET",
    handler: (app) => {
      return async (params) => {
        var _a, _b, _c;
        let iconicPluginSettings = (_c = (_b = (_a = app.plugins.plugins) == null ? void 0 : _a["iconic"]) == null ? void 0 : _b.settings) == null ? void 0 : _c.fileIcons;
        let directories = Object.values(app.vault.getAllFolders()).map((fi) => {
          var _a2, _b2;
          return {
            name: fi.name,
            path: fi.path,
            icon: (_b2 = (_a2 = iconicPluginSettings == null ? void 0 : iconicPluginSettings[fi.path]) == null ? void 0 : _a2.icon) != null ? _b2 : "folder"
          };
        });
        callback(params["x-success"], directories);
      };
    }
  },
  {
    path: "/vault/info",
    params: [],
    method: "GET",
    handler: (app) => {
      return async (params) => {
        let hasPeriodicNotes = app.plugins.enabledPlugins.has("periodic-notes");
        console.log("hasPeriodicNotes", hasPeriodicNotes);
        let vaultInfo = app.vault.getConfig();
        console.log("vaultInfo", vaultInfo);
        let vaultName = app.vault.getName();
        let actualInfo = app.vault.config;
        console.log("actualInfo", actualInfo);
        let returnInfo = {
          name: vaultName,
          id: app.appId
        };
        callback(params["x-success"], returnInfo);
      };
    }
  },
  {
    path: "/templates",
    params: [],
    method: "GET",
    handler: (app) => {
      return async (params) => {
        var _a, _b, _c;
        let pre_templates = (_c = (_b = (_a = app.plugins.plugins) == null ? void 0 : _a["templater-obsidian"]) == null ? void 0 : _b.settings) == null ? void 0 : _c.folder_templates;
        let templates = pre_templates.map((template) => {
          var _a2;
          return {
            path: template.folder,
            file: template.template,
            properties: (_a2 = app.metadataCache.getCache(template.template)) == null ? void 0 : _a2.frontmatter
          };
        });
        console.log("templates", templates);
        callback(params["x-success"], templates);
      };
    }
  },
  {
    path: "/capture/page",
    params: ["path", "data"],
    method: "GET",
    handler: (app) => {
      return async (params) => {
        try {
          let pathy = "";
          let filey = "";
          let datay = "";
          if (params.pathy) {
            pathy = decodeURIComponent(params.pathy);
          }
          if (params.file) {
            filey = decodeURIComponent(params.file);
          }
          datay = params.data;
          if (!pathy && !filey && !datay)
            return;
          let filePathFull = pathy + "/" + filey;
          await app.vault.create(filePathFull, datay);
        } catch (e) {
        }
      };
    }
  }
];

// main.ts
var FlylighterPlugin = class extends import_obsidian.Plugin {
  async onload() {
    let _app = this.app;
    let _vault = _app.vault;
    routes.forEach((route) => {
      this.registerObsidianProtocolHandler(
        "flylighter" + route.path,
        route.handler(_app)
      );
    });
  }
};
